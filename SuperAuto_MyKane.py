import logging
import asyncio
import json
import re
import os
from datetime import datetime
from telethon import TelegramClient, events
from telethon.errors import SessionPasswordNeededError
from telethon.tl.types import UserStatusOnline, UserStatusRecently, UserStatusLastWeek, UserStatusLastMonth
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes
from apscheduler.schedulers.asyncio import AsyncIOScheduler

# C·∫•u h√¨nh logging
logging.basicConfig(filename='bot.log', level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Th√¥ng tin bot
BOT_TOKEN = "7695124221:AAGhrm4zaIeMwtipSPqa_44Pq4gw9ZF4668"  # Token t·ª´ BotFather
API_ID = "24090485"  # API ID t·ª´ my.telegram.org
API_HASH = "b056e6499bc0d4a81ab375773ac1170c"  # API Hash t·ª´ my.telegram.org
ADMIN_IDS = [123456789]  # Thay b·∫±ng danh s√°ch ID c·ªßa admin

# L∆∞u tr·ªØ d·ªØ li·ªáu
clients = {}  # {chat_id: client}
user_data = {}  # {chat_id: {phone, source, target, blacklist, whitelist, replace_dict, emoji_replace, forward_mode, broadcast_enabled, broadcast_target, cleaners}}
forward_rules = {}  # {chat_id: {label: {source_chat_ids, target_chat_ids}}}
whitelist = {}  # {chat_id: {label: {type, words/pattern/users}}}
allowed_users = []  # Danh s√°ch ng∆∞·ªùi d√πng ƒë∆∞·ª£c ph√©p
settings = {"forward_enabled": True, "whitelist_enabled": True, "forward_mode": "forward"}  # C√†i ƒë·∫∑t m·∫∑c ƒë·ªãnh
statistics = {"forwarded_messages": [], "online_users": []}  # Th·ªëng k√™

# File ƒë·ªÉ l∆∞u c·∫•u h√¨nh
WHITELIST_FILE = "whitelist.json"
FORWARD_RULES_FILE = "forward_rules.json"
USERS_FILE = "users.json"
SETTINGS_FILE = "settings.json"
STATISTICS_FILE = "statistics.json"

# T·∫£i c·∫•u h√¨nh t·ª´ file
def load_whitelist():
    try:
        with open(WHITELIST_FILE, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_whitelist(whitelist):
    with open(WHITELIST_FILE, 'w') as f:
        json.dump(whitelist, f, indent=4)

def load_forward_rules():
    try:
        with open(FORWARD_RULES_FILE, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        return {}

def save_forward_rules(forward_rules):
    with open(FORWARD_RULES_FILE, 'w') as f:
        json.dump(forward_rules, f, indent=4)

def load_users():
    try:
        with open(USERS_FILE, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        return []

def save_users(users):
    with open(USERS_FILE, 'w') as f:
        json.dump(users, f, indent=4)

def load_settings():
    try:
        with open(SETTINGS_FILE, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        return {"forward_enabled": True, "whitelist_enabled": True, "forward_mode": "forward"}

def save_settings(settings):
    with open(SETTINGS_FILE, 'w') as f:
        json.dump(settings, f, indent=4)

def load_statistics():
    try:
        with open(STATISTICS_FILE, 'r') as f:
            return json.load(f)
    except FileNotFoundError:
        return {"forwarded_messages": [], "online_users": []}

def save_statistics(statistics):
    with open(STATISTICS_FILE, 'w') as f:
        json.dump(statistics, f, indent=4)

# Kh·ªüi t·∫°o d·ªØ li·ªáu
whitelist = load_whitelist()
forward_rules = load_forward_rules()
allowed_users = load_users()
settings = load_settings()
statistics = load_statistics()

# Kh·ªüi t·∫°o bot Telegram
application = Application.builder().token(BOT_TOKEN).build()

# Kh·ªüi t·∫°o scheduler ƒë·ªÉ l√™n l·ªãch
scheduler = AsyncIOScheduler()
scheduler.start()

# H√†m ki·ªÉm tra quy·ªÅn admin
def is_admin(user_id: int) -> bool:
    return user_id in ADMIN_IDS

# H√†m ki·ªÉm tra ng∆∞·ªùi d√πng ƒë∆∞·ª£c ph√©p
def is_allowed_user(user_id: int) -> bool:
    return user_id in allowed_users or user_id in ADMIN_IDS

# Menu ch√≠nh v·ªõi emoji
def main_menu():
    keyboard = [
        [InlineKeyboardButton("üîê ƒêƒÉng nh·∫≠p t√†i kho·∫£n", callback_data="login"),
         InlineKeyboardButton("üì• Th√™m ngu·ªìn", callback_data="add_source")],
        [InlineKeyboardButton("üì§ Th√™m ƒë√≠ch", callback_data="add_target"),
         InlineKeyboardButton("‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu chuy·ªÉn ti·∫øp", callback_data="start_forward")],
        [InlineKeyboardButton("üö´ Blacklist", callback_data="blacklist"),
         InlineKeyboardButton("‚úÖ Whitelist", callback_data="whitelist")],
        [InlineKeyboardButton("üîÑ Thay th·∫ø n·ªôi dung", callback_data="replace"),
         InlineKeyboardButton("üìÖ L√™n l·ªãch tin nh·∫Øn", callback_data="schedule")],
        [InlineKeyboardButton("üì¢ Broadcast", callback_data="broadcast_menu"),
         InlineKeyboardButton("üìä Th·ªëng k√™", callback_data="stats")],
        [InlineKeyboardButton("üìú Danh s√°ch nh√≥m/k√™nh", callback_data="list_chats"),
         InlineKeyboardButton("üßπ Cleaners Menu", callback_data="cleaners_menu")],  # Thay th·∫ø n√∫t "Tham gia k√™nh tin t·ª©c"
        [InlineKeyboardButton("üìã Forwarding Menu", callback_data="forward_menu"),
         InlineKeyboardButton("üë• User Management", callback_data="user_menu")],
        [InlineKeyboardButton("‚öôÔ∏è Settings", callback_data="settings_menu"),
         InlineKeyboardButton("üìÇ Filter Groups/Channels", callback_data="filter_menu")],
        [InlineKeyboardButton("üì± Recent Online Contacts", callback_data="recent_online"),
         InlineKeyboardButton("üìà Statistics", callback_data="statistics")]
    ]
    return InlineKeyboardMarkup(keyboard)

# Menu Cleaners
def cleaners_menu(chat_id):
    cleaners = user_data.get(chat_id, {}).get("cleaners", {
        "text": False, "audio": False, "url": False, "url_preview": False,
        "video": False, "sticker": False, "hashtag": False, "mention": False,
        "photo": False, "document": False, "video_note": False, "voice": False,
        "emoji": False, "dice": False, "photo_with_text": False, "animation": False
    })
    keyboard = [
        [InlineKeyboardButton(f"{'‚úÖ' if cleaners['text'] else 'üö´'} Text", callback_data="toggle_cleaner_text"),
         InlineKeyboardButton(f"{'‚úÖ' if cleaners['audio'] else 'üö´'} Audio", callback_data="toggle_cleaner_audio")],
        [InlineKeyboardButton(f"{'‚úÖ' if cleaners['url'] else 'üö´'} URL", callback_data="toggle_cleaner_url"),
         InlineKeyboardButton(f"{'‚úÖ' if cleaners['url_preview'] else 'üö´'} URL Preview", callback_data="toggle_cleaner_url_preview")],
        [InlineKeyboardButton(f"{'‚úÖ' if cleaners['video'] else 'üö´'} Video", callback_data="toggle_cleaner_video"),
         InlineKeyboardButton(f"{'‚úÖ' if cleaners['sticker'] else 'üö´'} Sticker", callback_data="toggle_cleaner_sticker")],
        [InlineKeyboardButton(f"{'‚úÖ' if cleaners['hashtag'] else 'üö´'} Hashtag", callback_data="toggle_cleaner_hashtag"),
         InlineKeyboardButton(f"{'‚úÖ' if cleaners['mention'] else 'üö´'} Mention", callback_data="toggle_cleaner_mention")],
        [InlineKeyboardButton(f"{'‚úÖ' if cleaners['photo'] else 'üö´'} Photo", callback_data="toggle_cleaner_photo"),
         InlineKeyboardButton(f"{'‚úÖ' if cleaners['document'] else 'üö´'} Document", callback_data="toggle_cleaner_document")],
        [InlineKeyboardButton(f"{'‚úÖ' if cleaners['video_note'] else 'üö´'} Video Note", callback_data="toggle_cleaner_video_note"),
         InlineKeyboardButton(f"{'‚úÖ' if cleaners['voice'] else 'üö´'} Voice", callback_data="toggle_cleaner_voice")],
        [InlineKeyboardButton(f"{'‚úÖ' if cleaners['emoji'] else 'üö´'} Emoji", callback_data="toggle_cleaner_emoji"),
         InlineKeyboardButton(f"{'‚úÖ' if cleaners['dice'] else 'üö´'} Dice", callback_data="toggle_cleaner_dice")],
        [InlineKeyboardButton(f"{'‚úÖ' if cleaners['photo_with_text'] else 'üö´'} Photo with Text", callback_data="toggle_cleaner_photo_with_text"),
         InlineKeyboardButton(f"{'‚úÖ' if cleaners['animation'] else 'üö´'} Animation", callback_data="toggle_cleaner_animation")],
        [InlineKeyboardButton("‚ùì How do I use this?", callback_data="cleaners_help")],
        [InlineKeyboardButton("‚¨ÖÔ∏è Return to Main Menu", callback_data="back")]
    ]
    return InlineKeyboardMarkup(keyboard)

# N√∫t quay l·∫°i
def back_button():
    return InlineKeyboardMarkup([[InlineKeyboardButton("üîô Quay l·∫°i", callback_data="back")]])

# L·ªánh /start
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    if not is_allowed_user(user_id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y!")
        return
    await update.message.reply_text("Ch√†o m·ª´ng b·∫°n! Ch·ªçn h√†nh ƒë·ªông:", reply_markup=main_menu())

# H√†m b·∫•t ƒë·ªìng b·ªô ƒë·ªÉ li·ªát k√™ nh√≥m/k√™nh
async def list_chats_async(chat_id, query):
    if chat_id not in clients:
        await query.edit_message_text(text="Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc!", reply_markup=main_menu())
        return
    chats = []
    async for dialog in clients[chat_id].iter_dialogs():
        username = dialog.entity.username if hasattr(dialog.entity, "username") and dialog.entity.username else "Kh√¥ng c√≥"
        chats.append(f"{dialog.name} (@{username}) - ID: {dialog.entity.id}")
    text = "üìú Danh s√°ch nh√≥m/k√™nh:\n" + "\n".join(chats) if chats else "Kh√¥ng t√¨m th·∫•y nh√≥m/k√™nh n√†o!‚Äú
    await query.edit_message_text(text=text, reply_markup=back_button())

# X·ª≠ l√Ω n√∫t
async def button(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    chat_id = query.message.chat_id
    user_id = query.from_user.id

    if not is_allowed_user(user_id):
        await query.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y!")
        return

    # Kh·ªüi t·∫°o cleaners n·∫øu ch∆∞a c√≥
    if chat_id not in user_data:
        user_data[chat_id] = {}
    if "cleaners" not in user_data[chat_id]:
        user_data[chat_id]["cleaners"] = {
            "text": False, "audio": False, "url": False, "url_preview": False,
            "video": False, "sticker": False, "hashtag": False, "mention": False,
            "photo": False, "document": False, "video_note": False, "voice": False,
            "emoji": False, "dice": False, "photo_with_text": False, "animation": False
        }

    if query.data == "login":
        await query.edit_message_text(text="G·ª≠i s·ªë ƒëi·ªán tho·∫°i c·ªßa b·∫°n (v√≠ d·ª•: +84123456789):", reply_markup=back_button())
        context.user_data["state"] = "waiting_phone"

    elif query.data == "add_source":
        await query.edit_message_text(text="G·ª≠i user_id c·ªßa k√™nh/nh√≥m ngu·ªìn (v√≠ d·ª•: -100123456789):", reply_markup=back_button())
        context.user_data["state"] = "waiting_source"

    elif query.data == "add_target":
        await query.edit_message_text(text="G·ª≠i user_id c·ªßa k√™nh/nh√≥m ƒë√≠ch (v√≠ d·ª•: -100987654321):", reply_markup=back_button())
        context.user_data["state"] = "waiting_target"

    elif query.data == "start_forward":
        if chat_id not in clients:
            await query.edit_message_text(text="Vui l√≤ng ƒëƒÉng nh·∫≠p t√†i kho·∫£n tr∆∞·ªõc!", reply_markup=main_menu())
        elif "source" not in user_data.get(chat_id, {}) or "target" not in user_data.get(chat_id, {}):
            await query.edit_message_text(text="Vui l√≤ng th√™m ngu·ªìn v√† ƒë√≠ch tr∆∞·ªõc!", reply_markup=main_menu())
        else:
            await query.edit_message_text(text="‚ñ∂Ô∏è ƒê√£ b·∫Øt ƒë·∫ßu chuy·ªÉn ti·∫øp!", reply_markup=main_menu())
            start_forwarding(chat_id, context)

    elif query.data == "blacklist":
        keyboard = [
            [InlineKeyboardButton("Th√™m t·ª´ kh√≥a", callback_data="add_blacklist_word"),
             InlineKeyboardButton("Th√™m user_id", callback_data="add_blacklist_id")],
            [InlineKeyboardButton("Xem danh s√°ch", callback_data="view_blacklist"),
             InlineKeyboardButton("Quay l·∫°i", callback_data="back")]
        ]
        await query.edit_message_text(text="üö´ Qu·∫£n l√Ω Blacklist:", reply_markup=InlineKeyboardMarkup(keyboard))

    elif query.data == "whitelist":
        keyboard = [
            [InlineKeyboardButton("Th√™m t·ª´ kh√≥a", callback_data="add_whitelist_word"),
             InlineKeyboardButton("Th√™m user_id", callback_data="add_whitelist_id")],
            [InlineKeyboardButton("Xem danh s√°ch", callback_data="view_whitelist"),
             InlineKeyboardButton("Quay l·∫°i", callback_data="back")]
        ]
        await query.edit_message_text(text="‚úÖ Qu·∫£n l√Ω Whitelist:", reply_markup=InlineKeyboardMarkup(keyboard))

    elif query.data.startswith("add_blacklist"):
        target = "word" if query.data == "add_blacklist_word" else "id"
        await query.edit_message_text(text=f"G·ª≠i {'t·ª´ kh√≥a' if target == 'word' else 'user_id'} ƒë·ªÉ th√™m v√†o blacklist:", reply_markup=back_button())
        context.user_data["state"] = f"waiting_blacklist_{target}"

    elif query.data.startswith("add_whitelist"):
        target = "word" if query.data == "add_whitelist_word" else "id"
        await query.edit_message_text(text=f"G·ª≠i {'t·ª´ kh√≥a' if target == 'word' else 'user_id'} ƒë·ªÉ th√™m v√†o whitelist:", reply_markup=back_button())
        context.user_data["state"] = f"waiting_whitelist_{target}"

    elif query.data == "view_blacklist":
        blacklist = user_data.get(chat_id, {}).get("blacklist", {"words": [], "ids": []})
        text = f"Blacklist:\nT·ª´ kh√≥a: {', '.join(blacklist['words']) or 'Tr·ªëng'}\nUser_ID: {', '.join(map(str, blacklist['ids'])) or 'Tr·ªëng'}"
        await query.edit_message_text(text=text, reply_markup=back_button())

    elif query.data == "view_whitelist":
        whitelist_data = user_data.get(chat_id, {}).get("whitelist", {"words": [], "ids": []})
        text = f"Whitelist:\nT·ª´ kh√≥a: {', '.join(whitelist_data['words']) or 'Tr·ªëng'}\nUser_ID: {', '.join(map(str, whitelist_data['ids'])) or 'Tr·ªëng'}"
        await query.edit_message_text(text=text, reply_markup=back_button())

    elif query.data == "replace":
        keyboard = [
            [InlineKeyboardButton("üìù Thay th·∫ø vƒÉn b·∫£n", callback_data="replace_text"),
             InlineKeyboardButton("üòä Thay th·∫ø emoji", callback_data="replace_emoji")],
            [InlineKeyboardButton("üñºÔ∏è Thay th·∫ø media", callback_data="replace_media"),
             InlineKeyboardButton("üîô Quay l·∫°i", callback_data="back")]
        ]
        await query.edit_message_text(text="üîÑ Ch·ªçn lo·∫°i thay th·∫ø:", reply_markup=InlineKeyboardMarkup(keyboard))

    elif query.data == "replace_text":
        await query.edit_message_text(text="üìù Nh·∫≠p c·∫∑p t·ª´ thay th·∫ø (v√≠ d·ª•: hello=>hi):", reply_markup=back_button())
        context.user_data["state"] = "waiting_replace_text"

    elif query.data == "replace_emoji":
        await query.edit_message_text(text="üòä Nh·∫≠p c·∫∑p emoji thay th·∫ø (v√≠ d·ª•: üòä=>üòÑ):", reply_markup=back_button())
        context.user_data["state"] = "waiting_replace_emoji"

    elif query.data == "replace_media":
        await query.edit_message_text(text="üñºÔ∏è T√≠nh nƒÉng thay th·∫ø media ƒëang ph√°t tri·ªÉn!", reply_markup=main_menu())

    elif query.data == "schedule":
        await query.edit_message_text(text="‚è∞ Nh·∫≠p th·ªùi gian v√† n·ªôi dung (v√≠ d·ª•: 1m Tin nh·∫Øn t·ª± ƒë·ªông):", reply_markup=back_button())
        context.user_data["state"] = "waiting_schedule"

    elif query.data == "broadcast_menu":
        broadcast_enabled = user_data.get(chat_id, {}).get("broadcast_enabled", False)
        keyboard = [
            [InlineKeyboardButton("üì¢ Broadcast ƒë·∫øn nh√≥m", callback_data="broadcast_groups"),
             InlineKeyboardButton("üì¢ Broadcast ƒë·∫øn danh b·∫°", callback_data="broadcast_contacts")],
            [InlineKeyboardButton("üì¢ Broadcast ƒë·∫øn t·∫•t c·∫£", callback_data="broadcast_all"),
             InlineKeyboardButton("üîô Quay l·∫°i", callback_data="back")],
            [InlineKeyboardButton("‚ñ∂Ô∏è B·∫Øt ƒë·∫ßu Broadcast" if not broadcast_enabled else "‚èπ K·∫øt th√∫c Broadcast",
                                  callback_data="start_broadcast" if not broadcast_enabled else "stop_broadcast")]
        ]
        status = "ƒëang ch·∫°y" if broadcast_enabled else "ƒë√£ d·ª´ng"
        await query.edit_message_text(text=f"üì¢ Ch·ªçn lo·∫°i broadcast (Tr·∫°ng th√°i: {status}):", reply_markup=InlineKeyboardMarkup(keyboard))

    elif query.data == "broadcast_groups":
        user_data[chat_id]["broadcast_target"] = "groups"
        await query.edit_message_text(text="üì¢ Nh·∫≠p n·ªôi dung broadcast ƒë·∫øn c√°c nh√≥m (ho·∫∑c g·ª≠i media ƒë·ªÉ chuy·ªÉn ti·∫øp):", reply_markup=back_button())
        context.user_data["state"] = "waiting_broadcast_groups"

    elif query.data == "broadcast_contacts":
        user_data[chat_id]["broadcast_target"] = "contacts"
        await query.edit_message_text(text="üì¢ Nh·∫≠p n·ªôi dung broadcast ƒë·∫øn danh b·∫° (ho·∫∑c g·ª≠i media ƒë·ªÉ chuy·ªÉn ti·∫øp):", reply_markup=back_button())
        context.user_data["state"] = "waiting_broadcast_contacts"

    elif query.data == "broadcast_all":
        user_data[chat_id]["broadcast_target"] = "all"
        await query.edit_message_text(text="üì¢ Nh·∫≠p n·ªôi dung broadcast ƒë·∫øn t·∫•t c·∫£ (ho·∫∑c g·ª≠i media ƒë·ªÉ chuy·ªÉn ti·∫øp):", reply_markup=back_button())
        context.user_data["state"] = "waiting_broadcast_all"

    elif query.data == "start_broadcast":
        if chat_id not in clients:
            await query.edit_message_text(text="Vui l√≤ng ƒëƒÉng nh·∫≠p t√†i kho·∫£n tr∆∞·ªõc!", reply_markup=main_menu())
        elif "source" not in user_data.get(chat_id, {}):
            await query.edit_message_text(text="Vui l√≤ng th√™m ngu·ªìn tr∆∞·ªõc!", reply_markup=main_menu())
        elif "broadcast_target" not in user_data.get(chat_id, {}):
            await query.edit_message_text(text="Vui l√≤ng ch·ªçn lo·∫°i broadcast tr∆∞·ªõc (nh√≥m, danh b·∫°, ho·∫∑c t·∫•t c·∫£)!", reply_markup=main_menu())
        else:
            user_data[chat_id]["broadcast_enabled"] = True
            setup_broadcast(chat_id)
            await query.edit_message_text(text="‚ñ∂Ô∏è ƒê√£ b·∫Øt ƒë·∫ßu broadcast!", reply_markup=main_menu())

    elif query.data == "stop_broadcast":
        user_data[chat_id]["broadcast_enabled"] = False
        await query.edit_message_text(text="‚èπ ƒê√£ k·∫øt th√∫c broadcast!", reply_markup=main_menu())

    elif query.data == "cleaners_menu":
        await query.edit_message_text(
            text="üßπ Cleaners Menu üßπ\n\n"
                 "Use this menu to remove specific content from messages when forwarding or broadcasting.\n"
                 "Toggle the cleaners to activate/deactivate them.",
            reply_markup=cleaners_menu(chat_id)
        )

    elif query.data.startswith("toggle_cleaner_"):
        cleaner_type = query.data.replace("toggle_cleaner_", "")
        user_data[chat_id]["cleaners"][cleaner_type] = not user_data[chat_id]["cleaners"][cleaner_type]
        await query.edit_message_text(
            text="üßπ Cleaners Menu üßπ\n\n"
                 "Use this menu to remove specific content from messages when forwarding or broadcasting.\n"
                 "Toggle the cleaners to activate/deactivate them.",
            reply_markup=cleaners_menu(chat_id)
        )

    elif query.data == "cleaners_help":
        await query.edit_message_text(
            text="‚ùì How do I use Cleaners? ‚ùì\n\n"
                 "Cleaners allow you to filter out specific content from messages when forwarding or broadcasting.\n\n"
                 "üîπ Toggle a cleaner to ‚úÖ to remove that content type (e.g., Text, Photo, URL).\n"
                 "üîπ Toggle it to üö´ to allow that content type.\n\n"
                 "Examples:\n"
                 "- If 'Text' is ‚úÖ, all text will be removed from messages.\n"
                 "- If 'Photo' is ‚úÖ, photos will be skipped during forwarding.\n\n"
                 "Use this to customize the content you want to forward or broadcast!",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è Return", callback_data="cleaners_menu")]])
        )

    elif query.data == "stats":
        await statistics_command(query.message, context)

    elif query.data == "list_chats":
        await list_chats_async(chat_id, query)

    elif query.data == "forward_menu":
        keyboard = [
            [InlineKeyboardButton("Clear All", callback_data="forward_clear"),
             InlineKeyboardButton("Show All", callback_data="forward_show")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("üì¢ Forwarding Assistance Menu üì¢\n\n"
                                      "Use this menu to configure auto message forwarding.\n\n"
                                      "üìñ Before using this command, retrieve chat IDs using /getchatid, /getgroup, or /getuser.\n\n"
                                      "Follow the format below when adding channels, users, or bots:\n"
                                      "/forward ACTION LABEL SOURCE_CHAT_ID -> TARGET_CHAT_ID\n\n"
                                      "‚ùó Note: The LABEL should not contain spaces or special characters. Keep it simple.\n\n"
                                      "========== Examples ==========\n\n"
                                      "üîπ One-to-One Chat\n"
                                      "/forward add work1 2222 -> 66666\n\n"
                                      "üîπ Many-to-One Chat\n"
                                      "/forward add work2 2222,33333 -> 66666\n\n"
                                      "üîπ One-to-Many Chat\n"
                                      "/forward add work3 2222 -> 66666,77777\n\n"
                                      "üîπ Many-to-Many Chat\n"
                                      "/forward add work4 2222,33333 -> 66666,77777\n\n"
                                      "üîπ Remove Rule\n"
                                      "/forward remove work1", reply_markup=reply_markup)

    elif query.data == "user_menu":
        if not is_admin(user_id):
            await query.edit_message_text(text="Ch·ªâ admin m·ªõi c√≥ th·ªÉ qu·∫£n l√Ω ng∆∞·ªùi d√πng!", reply_markup=main_menu())
            return
        await query.edit_message_text("üìã User Management Menu üìã\n\n"
                                      "Use these commands to manage users:\n"
                                      "/user add USER_ID - Th√™m ng∆∞·ªùi d√πng\n"
                                      "/user remove USER_ID - X√≥a ng∆∞·ªùi d√πng\n"
                                      "/user list - Hi·ªÉn th·ªã danh s√°ch ng∆∞·ªùi d√πng", reply_markup=back_button())

    elif query.data == "settings_menu":
        if not is_admin(user_id):
            await query.edit_message_text(text="Ch·ªâ admin m·ªõi c√≥ th·ªÉ thay ƒë·ªïi c√†i ƒë·∫∑t!", reply_markup=main_menu())
            return
        keyboard = [
            [InlineKeyboardButton("Toggle Forward: " + ("ON" if settings["forward_enabled"] else "OFF"),
                                  callback_data="toggle_forward")],
            [InlineKeyboardButton("Toggle Whitelist: " + ("ON" if settings["whitelist_enabled"] else "OFF"),
                                  callback_data="toggle_whitelist")],
            [InlineKeyboardButton("Forward Mode: " + ("Forward" if settings["forward_mode"] == "forward" else "Copy"),
                                  callback_data="toggle_forward_mode")],
            [InlineKeyboardButton("Quay l·∫°i", callback_data="back")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text("‚öôÔ∏è Settings Menu ‚öôÔ∏è\n\n"
                                      "Current Settings:\n"
                                      f"Forwarding: {'Enabled' if settings['forward_enabled'] else 'Disabled'}\n"
                                      f"Whitelist: {'Enabled' if settings['whitelist_enabled'] else 'Disabled'}\n"
                                      f"Forward Mode: {settings['forward_mode'].capitalize()}\n",
                                      reply_markup=reply_markup)

    elif query.data == "toggle_forward":
        if not is_admin(user_id):
            await query.edit_message_text(text="Ch·ªâ admin m·ªõi c√≥ th·ªÉ thay ƒë·ªïi c√†i ƒë·∫∑t!", reply_markup=main_menu())
            return
        settings["forward_enabled"] = not settings["forward_enabled"]
        save_settings(settings)
        await query.edit_message_text(f"Forwarding ƒë√£ ƒë∆∞·ª£c {'b·∫≠t' if settings['forward_enabled'] else 't·∫Øt'}.", reply_markup=main_menu())

    elif query.data == "toggle_whitelist":
        if not is_admin(user_id):
            await query.edit_message_text(text="Ch·ªâ admin m·ªõi c√≥ th·ªÉ thay ƒë·ªïi c√†i ƒë·∫∑t!", reply_markup=main_menu())
            return
        settings["whitelist_enabled"] = not settings["whitelist_enabled"]
        save_settings(settings)
        await query.edit_message_text(f"Whitelist ƒë√£ ƒë∆∞·ª£c {'b·∫≠t' if settings['whitelist_enabled'] else 't·∫Øt'}.", reply_markup=main_menu())

    elif query.data == "toggle_forward_mode":
        if not is_admin(user_id):
            await query.edit_message_text(text="Ch·ªâ admin m·ªõi c√≥ th·ªÉ thay ƒë·ªïi c√†i ƒë·∫∑t!", reply_markup=main_menu())
            return
        settings["forward_mode"] = "copy" if settings["forward_mode"] == "forward" else "forward"
        save_settings(settings)
        await query.edit_message_text(f"Forward Mode ƒë√£ ƒë∆∞·ª£c chuy·ªÉn th√†nh {'Copy' if settings['forward_mode'] == 'copy' else 'Forward'}.", reply_markup=main_menu())

    elif query.data == "forward_clear":
        if not is_admin(user_id):
            await query.edit_message_text(text="Ch·ªâ admin m·ªõi c√≥ th·ªÉ x√≥a quy t·∫Øc forward!", reply_markup=main_menu())
            return
        forward_rules[chat_id] = {}
        save_forward_rules(forward_rules)
        await query.edit_message_text("ƒê√£ x√≥a t·∫•t c·∫£ quy t·∫Øc forward.", reply_markup=main_menu())

    elif query.data == "forward_show":
        if chat_id not in forward_rules or not forward_rules[chat_id]:
            await query.edit_message_text("Hi·ªán t·∫°i kh√¥ng c√≥ quy t·∫Øc forward n√†o.", reply_markup=main_menu())
            return
        response = "üìã Danh s√°ch quy t·∫Øc forward:\n\n"
        for label, rule in forward_rules[chat_id].items():
            response += f"üîπ {label}: {rule['source_chat_ids']} -> {rule['target_chat_ids']}\n"
        await query.edit_message_text(response, reply_markup=back_button())

    elif query.data == "filter_menu":
        await query.edit_message_text("üìÇ Filter Menu üìÇ\n\n"
                                      "Use these commands to filter groups, channels, or usernames:\n"
                                      "/filtergroups - L·ªçc danh s√°ch nh√≥m\n"
                                      "/filterchannels - L·ªçc danh s√°ch k√™nh\n"
                                      "/filterusername USERNAME - T√¨m ki·∫øm theo username", reply_markup=back_button())

    elif query.data == "recent_online":
        await recent_online(query.message, context)

    elif query.data == "statistics":
        await statistics_command(query.message, context)

    elif query.data == "back":
        await query.edit_message_text(text="Ch√†o m·ª´ng! Ch·ªçn h√†nh ƒë·ªông:", reply_markup=main_menu())

# X·ª≠ l√Ω tin nh·∫Øn t·ª´ ng∆∞·ªùi d√πng
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    chat_id = update.message.chat_id
    user_id = update.effective_user.id
    text = update.message.text
    message = update.message

    if not is_allowed_user(user_id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y!")
        return

    user_data[chat_id] = user_data.get(chat_id, {})
    if "state" not in context.user_data:
        return

    state = context.user_data["state"]

    if state == "waiting_phone":
        user_data[chat_id]["phone"] = text
        client = TelegramClient(f"sessions/{chat_id}_{text}", API_ID, API_HASH)
        await client.connect()
        if not await client.is_user_authorized():
            await client.send_code_request(text)
            await update.message.reply_text("G·ª≠i m√£ OTP b·∫°n nh·∫≠n ƒë∆∞·ª£c:", reply_markup=back_button())
            context.user_data["state"] = "waiting_code"
            context.user_data["client"] = client
        else:
            clients[chat_id] = client
            setup_forwarding(chat_id)
            setup_broadcast(chat_id)  # Thi·∫øt l·∫≠p broadcast sau khi ƒëƒÉng nh·∫≠p
            await update.message.reply_text("ƒê√£ ƒëƒÉng nh·∫≠p th√†nh c√¥ng t·ª´ phi√™n tr∆∞·ªõc!", reply_markup=main_menu())
            context.user_data["state"] = None

    elif state == "waiting_code":
        client = context.user_data["client"]
        try:
            await client.sign_in(code=text)
            clients[chat_id] = client
            setup_forwarding(chat_id)
            setup_broadcast(chat_id)  # Thi·∫øt l·∫≠p broadcast sau khi ƒëƒÉng nh·∫≠p
            await update.message.reply_text("ƒêƒÉng nh·∫≠p th√†nh c√¥ng!", reply_markup=main_menu())
        except SessionPasswordNeededError:
            await update.message.reply_text("T√†i kho·∫£n y√™u c·∫ßu m·∫≠t kh·∫©u x√°c minh hai b∆∞·ªõc. Nh·∫≠p m·∫≠t kh·∫©u:", reply_markup=back_button())
            context.user_data["state"] = "waiting_password"
        except Exception as e:
            await update.message.reply_text(f"L·ªói: {str(e)}. Vui l√≤ng th·ª≠ l·∫°i.", reply_markup=main_menu())
            context.user_data["state"] = None

    elif state == "waiting_password":
        client = context.user_data["client"]
        try:
            await client.sign_in(password=text)
            clients[chat_id] = client
            setup_forwarding(chat_id)
            setup_broadcast(chat_id)  # Thi·∫øt l·∫≠p broadcast sau khi ƒëƒÉng nh·∫≠p
            await update.message.reply_text("ƒêƒÉng nh·∫≠p th√†nh c√¥ng!", reply_markup=main_menu())
        except Exception as e:
            await update.message.reply_text(f"L·ªói: {str(e)}. Vui l√≤ng th·ª≠ l·∫°i.", reply_markup=main_menu())
        context.user_data["state"] = None

    elif state == "waiting_source":
        user_data[chat_id]["source"] = int(text)
        await update.message.reply_text(f"Ngu·ªìn ƒë√£ ƒë·∫∑t: {text}", reply_markup=main_menu())
        context.user_data["state"] = None

    elif state == "waiting_target":
        user_data[chat_id]["target"] = int(text)
        await update.message.reply_text(f"ƒê√≠ch ƒë√£ ƒë·∫∑t: {text}", reply_markup=main_menu())
        context.user_data["state"] = None

    elif state.startswith("waiting_blacklist"):
        target = "words" if state == "waiting_blacklist_word" else "ids"
        user_data[chat_id]["blacklist"] = user_data[chat_id].get("blacklist", {"words": [], "ids": []})
        value = text if target == "words" else int(text)
        user_data[chat_id]["blacklist"][target].append(value)
        await update.message.reply_text(f"ƒê√£ th√™m {value} v√†o blacklist!", reply_markup=main_menu())
        context.user_data["state"] = None

    elif state.startswith("waiting_whitelist"):
        target = "words" if state == "waiting_whitelist_word" else "ids"
        user_data[chat_id]["whitelist"] = user_data[chat_id].get("whitelist", {"words": [], "ids": []})
        value = text if target == "words" else int(text)
        user_data[chat_id]["whitelist"][target].append(value)
        await update.message.reply_text(f"ƒê√£ th√™m {value} v√†o whitelist!", reply_markup=main_menu())
        context.user_data["state"] = None

    elif state == "waiting_replace_text":
        try:
            key, value = text.split("=>")
            user_data[chat_id]["replace_dict"] = user_data[chat_id].get("replace_dict", {})
            user_data[chat_id]["replace_dict"][key.strip()] = value.strip()
            await update.message.reply_text(f"ƒê√£ th√™m thay th·∫ø: {key} => {value}", reply_markup=main_menu())
        except:
            await update.message.reply_text("ƒê·ªãnh d·∫°ng kh√¥ng ƒë√∫ng! Vui l√≤ng nh·∫≠p l·∫°i (v√≠ d·ª•: hello=>hi).", reply_markup=back_button())
        context.user_data["state"] = None

    elif state == "waiting_replace_emoji":
        try:
            key, value = text.split("=>")
            user_data[chat_id]["emoji_replace"] = user_data[chat_id].get("emoji_replace", {})
            user_data[chat_id]["emoji_replace"][key.strip()] = value.strip()
            await update.message.reply_text(f"ƒê√£ th√™m thay th·∫ø emoji: {key} => {value}", reply_markup=main_menu())
        except:
            await update.message.reply_text("ƒê·ªãnh d·∫°ng kh√¥ng ƒë√∫ng! Vui l√≤ng nh·∫≠p l·∫°i (v√≠ d·ª•: üòä=>üòÑ).", reply_markup=back_button())
        context.user_data["state"] = None

    elif state == "waiting_schedule":
        try:
            parts = text.split(" ", 1)
            interval, message = parts[0], parts[1]
            interval_minutes = int(interval.replace("m", ""))
            target = user_data[chat_id]["target"]
            scheduler.add_job(scheduled_message, 'interval', minutes=interval_minutes, args=[clients[chat_id], target, message])
            await update.message.reply_text(f"‚è∞ ƒê√£ l√™n l·ªãch g·ª≠i tin nh·∫Øn m·ªói {interval_minutes} ph√∫t: {message}", reply_markup=main_menu())
        except:
            await update.message.reply_text("ƒê·ªãnh d·∫°ng kh√¥ng ƒë√∫ng! Vui l√≤ng nh·∫≠p l·∫°i (v√≠ d·ª•: 1m Tin nh·∫Øn t·ª± ƒë·ªông).", reply_markup=back_button())
        context.user_data["state"] = None

    elif state == "waiting_broadcast_groups":
        if chat_id in clients:
            await broadcast_message(clients[chat_id], message, target="groups")
            await update.message.reply_text("üì¢ ƒê√£ g·ª≠i tin nh·∫Øn h√†ng lo·∫°t ƒë·∫øn c√°c nh√≥m!", reply_markup=main_menu())
        else:
            await update.message.reply_text("Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc!", reply_markup=main_menu())
        context.user_data["state"] = None

    elif state == "waiting_broadcast_contacts":
        if chat_id in clients:
            await broadcast_message(clients[chat_id], message, target="contacts")
            await update.message.reply_text("üì¢ ƒê√£ g·ª≠i tin nh·∫Øn h√†ng lo·∫°t ƒë·∫øn danh b·∫°!", reply_markup=main_menu())
        else:
            await update.message.reply_text("Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc!", reply_markup=main_menu())
        context.user_data["state"] = None

    elif state == "waiting_broadcast_all":
        if chat_id in clients:
            await broadcast_message(clients[chat_id], message, target="all")
            await update.message.reply_text("üì¢ ƒê√£ g·ª≠i tin nh·∫Øn h√†ng lo·∫°t ƒë·∫øn t·∫•t c·∫£!", reply_markup=main_menu())
        else:
            await update.message.reply_text("Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc!", reply_markup=main_menu())
        context.user_data["state"] = None

# H√†m x·ª≠ l√Ω l·ªánh /start_broadcast
async def start_broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    chat_id = update.message.chat_id
    user_id = update.effective_user.id

    if not is_allowed_user(user_id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y!")
        return

    if chat_id not in clients:
        await update.message.reply_text("Vui l√≤ng ƒëƒÉng nh·∫≠p t√†i kho·∫£n tr∆∞·ªõc!")
        return

    if "source" not in user_data.get(chat_id, {}):
        await update.message.reply_text("Vui l√≤ng th√™m ngu·ªìn tr∆∞·ªõc!")
        return

    if "broadcast_target" not in user_data.get(chat_id, {}):
        await update.message.reply_text("Vui l√≤ng ch·ªçn lo·∫°i broadcast tr∆∞·ªõc (nh√≥m, danh b·∫°, ho·∫∑c t·∫•t c·∫£)!")
        return

    user_data[chat_id]["broadcast_enabled"] = True
    setup_broadcast(chat_id)
    await update.message.reply_text("‚ñ∂Ô∏è ƒê√£ b·∫Øt ƒë·∫ßu broadcast!")

# H√†m x·ª≠ l√Ω l·ªánh /stop_broadcast
async def stop_broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    chat_id = update.message.chat_id
    user_id = update.effective_user.id

    if not is_allowed_user(user_id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y!")
        return

    user_data[chat_id]["broadcast_enabled"] = False
    await update.message.reply_text("‚èπ ƒê√£ k·∫øt th√∫c broadcast!")

# H√†m x·ª≠ l√Ω l·ªánh /forward
async def forward_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    chat_id = update.message.chat_id
    if not is_admin(user_id):
        await update.message.reply_text("Ch·ªâ admin m·ªõi c√≥ th·ªÉ c·∫•u h√¨nh forward!")
        return

    if not context.args or len(context.args) < 3:
        keyboard = [
            [InlineKeyboardButton("Clear All", callback_data="forward_clear"),
             InlineKeyboardButton("Show All", callback_data="forward_show")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text("üì¢ Forwarding Assistance Menu üì¢\n\n"
                                        "Use this menu to configure auto message forwarding.\n\n"
                                        "üìñ Before using this command, retrieve chat IDs using /getchatid, /getgroup, or /getuser.\n\n"
                                        "Follow the format below when adding channels, users, or bots:\n"
                                        "/forward ACTION LABEL SOURCE_CHAT_ID -> TARGET_CHAT_ID\n\n"
                                        "‚ùó Note: The LABEL should not contain spaces or special characters. Keep it simple.\n\n"
                                        "========== Examples ==========\n\n"
                                        "üîπ One-to-One Chat\n"
                                        "/forward add work1 2222 -> 66666\n\n"
                                        "üîπ Many-to-One Chat\n"
                                        "/forward add work2 2222,33333 -> 66666\n\n"
                                        "üîπ One-to-Many Chat\n"
                                        "/forward add work3 2222 -> 66666,77777\n\n"
                                        "üîπ Many-to-Many Chat\n"
                                        "/forward add work4 2222,33333 -> 66666,77777\n\n"
                                        "üîπ Remove Rule\n"
                                        "/forward remove work1", reply_markup=reply_markup)
        return

    try:
        action = context.args[0].lower()
        label = context.args[1]

        if action not in ["add", "remove"]:
            await update.message.reply_text("H√†nh ƒë·ªông kh√¥ng h·ª£p l·ªá! S·ª≠ d·ª•ng 'add' ho·∫∑c 'remove'.")
            return

        if action == "add":
            command_text = " ".join(context.args[2:])
            if "->" not in command_text:
                await update.message.reply_text("C√∫ ph√°p kh√¥ng h·ª£p l·ªá! S·ª≠ d·ª•ng: /forward add LABEL SOURCE_CHAT_ID -> TARGET_CHAT_ID")
                return

            source_part, target_part = command_text.split("->")
            source_chat_ids = [int(chat_id.strip()) for chat_id in source_part.split(",") if chat_id.strip()]
            target_chat_ids = [int(chat_id.strip()) for chat_id in target_part.split(",") if chat_id.strip()]

            if not source_chat_ids or not target_chat_ids:
                await update.message.reply_text("Vui l√≤ng cung c·∫•p SOURCE_CHAT_ID v√† TARGET_CHAT_ID h·ª£p l·ªá!")
                return

            if not re.match(r'^[a-zA-Z0-9_]+$', label):
                await update.message.reply_text("LABEL kh√¥ng ƒë∆∞·ª£c ch·ª©a kho·∫£ng tr·∫Øng ho·∫∑c k√Ω t·ª± ƒë·∫∑c bi·ªát!")
                return

            if chat_id not in forward_rules:
                forward_rules[chat_id] = {}
            forward_rules[chat_id][label] = {
                "source_chat_ids": source_chat_ids,
                "target_chat_ids": target_chat_ids
            }
            save_forward_rules(forward_rules)
            await update.message.reply_text(f"ƒê√£ th√™m quy t·∫Øc forward v·ªõi label '{label}'.")

        elif action == "remove":
            if chat_id in forward_rules and label in forward_rules[chat_id]:
                del forward_rules[chat_id][label]
                if not forward_rules[chat_id]:
                    del forward_rules[chat_id]
                save_forward_rules(forward_rules)
                await update.message.reply_text(f"ƒê√£ x√≥a quy t·∫Øc forward v·ªõi label '{label}'.")
            else:
                await update.message.reply_text(f"Kh√¥ng t√¨m th·∫•y quy t·∫Øc forward v·ªõi label '{label}'.")

    except Exception as e:
        await update.message.reply_text(f"L·ªói: {str(e)}")

# H√†m x·ª≠ l√Ω l·ªánh /whitelist
async def whitelist_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    chat_id = update.message.chat_id
    if not is_admin(user_id):
        await update.message.reply_text("Ch·ªâ admin m·ªõi c√≥ th·ªÉ c·∫•u h√¨nh whitelist!")
        return

    if not context.args:
        await update.message.reply_text("‚ùáÔ∏è Whitelist Help Menu ‚ùáÔ∏è\n\n"
                                        "Basic Command:\n/whitelist ACTION LABEL WORD_LIST\n\n"
                                        "Advanced Command (Regex):\n/whitelist ACTION LABEL_regex WORD_LIST\n"
                                        "/whitelist ACTION LABEL_user LIST_USER\n\n"
                                        "üìñ WORD_LIST: Distinguish between uppercase and lowercase letters\n"
                                        "üìñ LIST_USER: It could be User ID or username\n\n"
                                        "‚úÖ Basic Examples:\n"
                                        "‚û°Ô∏è /whitelist add label1 copyright\n"
                                        "‚û°Ô∏è /whitelist add label1 copyright,DMCA\n\n"
                                        "‚úÖ Advanced Examples:\n"
                                        "‚û°Ô∏è /whitelist add label1_regex (black|white)\n"
                                        "‚û°Ô∏è /whitelist add group1_user zinREAL,410995490\n"
                                        "‚û°Ô∏è /whitelist add label1_regex hello==AND==bye\n"
                                        "‚û°Ô∏è /whitelist remove label1")
        return

    try:
        action = context.args[0].lower()
        label = context.args[1]
        items = context.args[2] if len(context.args) > 2 else ""

        if action not in ["add", "remove"]:
            await update.message.reply_text("H√†nh ƒë·ªông kh√¥ng h·ª£p l·ªá! S·ª≠ d·ª•ng 'add' ho·∫∑c 'remove'.")
            return

        if action == "add":
            if not items:
                await update.message.reply_text("Vui l√≤ng cung c·∫•p WORD_LIST ho·∫∑c LIST_USER!")
                return

            if chat_id not in whitelist:
                whitelist[chat_id] = {}
            if label.endswith("_regex"):
                whitelist[chat_id][label] = {"type": "regex", "pattern": items}
            elif label.endswith("_user"):
                user_list = [item.strip() for item in items.split(",")]
                whitelist[chat_id][label] = {"type": "user", "users": user_list}
            else:
                word_list = [word.strip() for word in items.split(",")]
                whitelist[chat_id][label] = {"type": "word", "words": word_list}

            save_whitelist(whitelist)
            await update.message.reply_text(f"ƒê√£ th√™m whitelist v·ªõi label '{label}'.")

        elif action == "remove":
            if chat_id in whitelist and label in whitelist[chat_id]:
                del whitelist[chat_id][label]
                if not whitelist[chat_id]:
                    del whitelist[chat_id]
                save_whitelist(whitelist)
                await update.message.reply_text(f"ƒê√£ x√≥a whitelist v·ªõi label '{label}'.")
            else:
                await update.message.reply_text(f"Kh√¥ng t√¨m th·∫•y whitelist v·ªõi label '{label}'.")

    except Exception as e:
        await update.message.reply_text(f"L·ªói: {str(e)}")

# H√†m x·ª≠ l√Ω l·ªánh /user
async def user_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    if not is_admin(user_id):
        await update.message.reply_text("Ch·ªâ admin m·ªõi c√≥ th·ªÉ qu·∫£n l√Ω ng∆∞·ªùi d√πng!")
        return

    if not context.args:
        await update.message.reply_text("üìã User Management Menu üìã\n\n"
                                        "Use these commands to manage users:\n"
                                        "/user add USER_ID - Th√™m ng∆∞·ªùi d√πng\n"
                                        "/user remove USER_ID - X√≥a ng∆∞·ªùi d√πng\n"
                                        "/user list - Hi·ªÉn th·ªã danh s√°ch ng∆∞·ªùi d√πng")
        return

    try:
        action = context.args[0].lower()
        if action == "add":
            new_user_id = int(context.args[1])
            if new_user_id not in allowed_users:
                allowed_users.append(new_user_id)
                save_users(allowed_users)
                await update.message.reply_text(f"ƒê√£ th√™m ng∆∞·ªùi d√πng {new_user_id}.")
            else:
                await update.message.reply_text(f"Ng∆∞·ªùi d√πng {new_user_id} ƒë√£ c√≥ trong danh s√°ch.")

        elif action == "remove":
            user_id_to_remove = int(context.args[1])
            if user_id_to_remove in allowed_users:
                allowed_users.remove(user_id_to_remove)
                save_users(allowed_users)
                await update.message.reply_text(f"ƒê√£ x√≥a ng∆∞·ªùi d√πng {user_id_to_remove}.")
            else:
                await update.message.reply_text(f"Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng {user_id_to_remove}.")

        elif action == "list":
            if not allowed_users:
                await update.message.reply_text("Hi·ªán t·∫°i kh√¥ng c√≥ ng∆∞·ªùi d√πng n√†o ƒë∆∞·ª£c ph√©p.")
                return
            response = "üìã Danh s√°ch ng∆∞·ªùi d√πng ƒë∆∞·ª£c ph√©p:\n\n"
            for user_id in allowed_users:
                response += f"üîπ {user_id}\n"
            await update.message.reply_text(response)

    except Exception as e:
        await update.message.reply_text(f"L·ªói: {str(e)}")

# H√†m x·ª≠ l√Ω l·ªánh /getchatid, /getgroup, /getuser
async def getchatid(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    if not is_allowed_user(user_id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y!")
        return
    chat_id = update.effective_chat.id
    await update.message.reply_text(f"Chat ID: {chat_id}")

async def getgroup(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    if not is_allowed_user(user_id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y!")
        return
    if update.effective_chat.type not in ["group", "supergroup"]:
        await update.message.reply_text("L·ªánh n√†y ch·ªâ ho·∫°t ƒë·ªông trong group!")
        return
    chat_id = update.effective_chat.id
    await update.message.reply_text(f"Group ID: {chat_id}")

async def getuser(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    if not is_allowed_user(user_id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y!")
        return
    user_id = update.effective_user.id
    await update.message.reply_text(f"User ID: {user_id}")

# H√†m x·ª≠ l√Ω l·ªánh /filtergroups
async def filter_groups(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    chat_id = update.message.chat_id
    if not is_allowed_user(user_id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y!")
        return

    if chat_id not in clients:
        await update.message.reply_text("Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc!")
        return

    try:
        dialogs = await clients[chat_id].get_dialogs()
        groups = [d for d in dialogs if d.is_group]
        if not groups:
            await update.message.reply_text("Kh√¥ng t√¨m th·∫•y nh√≥m n√†o!")
            return

        response = "üìã Danh s√°ch nh√≥m:\n\n"
        for group in groups:
            response += f"üîπ {group.title} (ID: {group.id})\n"
        await update.message.reply_text(response)

    except Exception as e:
        await update.message.reply_text(f"L·ªói: {str(e)}")

# H√†m x·ª≠ l√Ω l·ªánh /filterchannels
async def filter_channels(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    chat_id = update.message.chat_id
    if not is_allowed_user(user_id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y!")
        return

    if chat_id not in clients:
        await update.message.reply_text("Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc!")
        return

    try:
        dialogs = await clients[chat_id].get_dialogs()
        channels = [d for d in dialogs if d.is_channel]
        if not channels:
            await update.message.reply_text("Kh√¥ng t√¨m th·∫•y k√™nh n√†o!")
            return

        response = "üìã Danh s√°ch k√™nh:\n\n"
        for channel in channels:
            response += f"üîπ {channel.title} (ID: {channel.id})\n"
        await update.message.reply_text(response)

    except Exception as e:
        await update.message.reply_text(f"L·ªói: {str(e)}")

# H√†m x·ª≠ l√Ω l·ªánh /filterusername
async def filter_username(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    chat_id = update.message.chat_id
    if not is_allowed_user(user_id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y!")
        return

    if chat_id not in clients:
        await update.message.reply_text("Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc!")
        return

    if not context.args:
        await update.message.reply_text("Vui l√≤ng cung c·∫•p username! V√≠ d·ª•: /filterusername username")
        return

    username = context.args[0].strip()
    try:
        entity = await clients[chat_id].get_entity(username)
        response = "üìã K·∫øt qu·∫£ t√¨m ki·∫øm:\n\n"
        if hasattr(entity, 'title'):
            response += f"üîπ {entity.title} (ID: {entity.id}, Type: {'Channel' if entity.broadcast else 'Group'})\n"
        else:
            response += f"üîπ {entity.first_name} {entity.last_name or ''} (ID: {entity.id}, Type: User, Username: @{entity.username})\n"
        await update.message.reply_text(response)

    except Exception as e:
        await update.message.reply_text(f"L·ªói: {str(e)}")

# H√†m x·ª≠ l√Ω l·ªánh /recentonline
async def recent_online(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    chat_id = update.message.chat_id
    if not is_allowed_user(user_id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y!")
        return

    if chat_id not in clients:
        await update.message.reply_text("Vui l√≤ng ƒëƒÉng nh·∫≠p tr∆∞·ªõc!")
        return

    try:
        contacts = await clients[chat_id].get_contacts()
        if not contacts:
            await update.message.reply_text("Danh b·∫° c·ªßa b·∫°n tr·ªëng!")
            return

        online_users = []
        for user in contacts:
            status = user.status
            if isinstance(status, UserStatusOnline):
                online_users.append((user, "Online"))
            elif isinstance(status, UserStatusRecently):
                online_users.append((user, "Recently Online"))
            elif isinstance(status, UserStatusLastWeek):
                online_users.append((user, "Last Week"))
            elif isinstance(status, UserStatusLastMonth):
                online_users.append((user, "Last Month"))

        if not online_users:
            await update.message.reply_text("Kh√¥ng c√≥ ng∆∞·ªùi d√πng n√†o online g·∫ßn ƒë√¢y trong danh b·∫°!")
            return

        online_users.sort(key=lambda x: ["Online", "Recently Online", "Last Week", "Last Month"].index(x[1]))

        response = "üìã Danh s√°ch ng∆∞·ªùi d√πng online g·∫ßn nh·∫•t:\n\n"
        for user, status in online_users[:10]:
            response += f"üîπ {user.first_name} {user.last_name or ''} (@{user.username or 'N/A'}) - {status}\n"
            statistics["online_users"].append({
                "user_id": user.id,
                "username": user.username,
                "status": status,
                "timestamp": datetime.now().isoformat()
            })

        save_statistics(statistics)
        await update.message.reply_text(response)

    except Exception as e:
        await update.message.reply_text(f"L·ªói: {str(e)}")

# H√†m x·ª≠ l√Ω l·ªánh /statistics
async def statistics_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    if not is_allowed_user(user_id):
        await update.message.reply_text("B·∫°n kh√¥ng c√≥ quy·ªÅn s·ª≠ d·ª•ng bot n√†y!")
        return

    try:
        start_time = datetime(2025, 3, 22, 0, 0, 0)
        end_time = datetime.now()

        forwarded_count = sum(1 for msg in statistics["forwarded_messages"]
                             if start_time <= datetime.fromisoformat(msg["timestamp"]) <= end_time)

        online_count = sum(1 for user in statistics["online_users"]
                           if start_time <= datetime.fromisoformat(user["timestamp"]) <= end_time)

        response = "üìä Th·ªëng k√™ t·ª´ 00:00 22/03/2025 ƒë·∫øn 11:02 23/03/2025 üìä\n\n"
        response += f"S·ªë tin nh·∫Øn ƒë√£ chuy·ªÉn ti·∫øp: {forwarded_count}\n"
        response += f"S·ªë ng∆∞·ªùi d√πng online (ƒë√£ ki·ªÉm tra): {online_count}\n"

        await update.reply_text(response)

    except Exception as e:
        await update.reply_text(f"L·ªói: {str(e)}")

# H√†m thay th·∫ø n·ªôi dung
def replace_content(chat_id, text):
    replace_dict = user_data.get(chat_id, {}).get("replace_dict", {})
    emoji_replace = user_data.get(chat_id, {}).get("emoji_replace", {})
    
    for key, value in replace_dict.items():
        text = re.sub(r'\b' + key + r'\b', value, text, flags=re.IGNORECASE)
    
    for emoji, replacement in emoji_replace.items():
        text = text.replace(emoji, replacement)
    
    return text

# H√†m l·ªçc n·ªôi dung d·ª±a tr√™n cleaners
def apply_cleaners(chat_id, message):
    cleaners = user_data.get(chat_id, {}).get("cleaners", {
        "text": False, "audio": False, "url": False, "url_preview": False,
        "video": False, "sticker": False, "hashtag": False, "mention": False,
        "photo": False, "document": False, "video_note": False, "voice": False,
        "emoji": False, "dice": False, "photo_with_text": False, "animation": False
    })
    msg_text = message.text or ""
    should_forward = True

    # Ki·ªÉm tra c√°c b·ªô l·ªçc
    if cleaners["text"] and msg_text:
        msg_text = ""
    if cleaners["url"] and msg_text:
        msg_text = re.sub(r'http[s]?://\S+|www\.\S+', '', msg_text)
    if cleaners["hashtag"] and msg_text:
        msg_text = re.sub(r'#\w+', '', msg_text)
    if cleaners["mention"] and msg_text:
        msg_text = re.sub(r'@\w+', '', msg_text)
    if cleaners["emoji"] and msg_text:
        msg_text = re.sub(r'[\U0001F600-\U0001F64F\U0001F300-\U0001F5FF\U0001F680-\U0001F6FF\U0001F1E0-\U0001F1FF]', '', msg_text)
    if cleaners["photo"] and message.photo:
        should_forward = False
    if cleaners["photo_with_text"] and message.photo and msg_text:
        should_forward = False
    if cleaners["video"] and message.video:
        should_forward = False
    if cleaners["audio"] and message.audio:
        should_forward = False
    if cleaners["document"] and message.document:
        should_forward = False
    if cleaners["sticker"] and message.sticker:
        should_forward = False
    if cleaners["video_note"] and message.video_note:
        should_forward = False
    if cleaners["voice"] and message.voice:
        should_forward = False
    if cleaners["dice"] and message.dice:
        should_forward = False
    if cleaners["animation"] and message.animation:
        should_forward = False

    # N·∫øu kh√¥ng c√≤n n·ªôi dung ƒë·ªÉ g·ª≠i, b·ªè qua tin nh·∫Øn
    if not should_forward and not msg_text:
        return None, None

    # C·∫≠p nh·∫≠t n·ªôi dung tin nh·∫Øn
    message.text = msg_text
    return message, should_forward

# H√†m l√™n l·ªãch g·ª≠i tin nh·∫Øn
async def scheduled_message(client, target, message):
    try:
        await client.send_message(target, message)
        logging.info(f"ƒê√£ g·ª≠i tin nh·∫Øn t·ª± ƒë·ªông ƒë·∫øn {target}: {message}")
    except Exception as e:
        logging.error(f"L·ªói khi g·ª≠i tin nh·∫Øn t·ª± ƒë·ªông: {str(e)}")

# H√†m g·ª≠i tin nh·∫Øn h√†ng lo·∫°t
async def broadcast_message(client, message, target="all"):
    # √Åp d·ª•ng cleaners tr∆∞·ªõc khi broadcast
    chat_id = list(clients.keys())[list(clients.values()).index(client)]
    message, should_forward = apply_cleaners(chat_id, message)
    if not should_forward or message is None:
        return

    sent_to = set()
    async for dialog in client.iter_dialogs():
        should_send = False
        if target == "all":
            should_send = dialog.is_group or dialog.is_user
        elif target == "groups":
            should_send = dialog.is_group
        elif target == "contacts":
            should_send = dialog.is_user

        if should_send and dialog.entity.id not in sent_to:
            try:
                if settings["forward_mode"] == "forward":
                    await client.forward_messages(dialog.entity, message)
                else:  # copy mode
                    msg_text = message.text or ""
                    if message.media:
                        if message.photo:
                            await client.send_file(dialog.entity, message.photo, caption=msg_text)
                        elif message.video:
                            await client.send_file(dialog.entity, message.video, caption=msg_text)
                        elif message.document:
                            await client.send_file(dialog.entity, message.document, caption=msg_text)
                        else:
                            new_text = replace_content(chat_id, msg_text)
                            await client.send_message(dialog.entity, new_text)
                    else:
                        new_text = replace_content(chat_id, msg_text)
                        await client.send_message(dialog.entity, new_text)

                sent_to.add(dialog.entity.id)
                logging.info(f"ƒê√£ g·ª≠i broadcast ƒë·∫øn {dialog.name}")
                await asyncio.sleep(1)  # Tr√°nh gi·ªõi h·∫°n Telegram
            except Exception as e:
                logging.error(f"L·ªói khi g·ª≠i broadcast ƒë·∫øn {dialog.name}: {str(e)}")

# H√†m ki·ªÉm tra tin nh·∫Øn c√≥ th·ªèa m√£n whitelist kh√¥ng
def check_whitelist(chat_id, message_text: str, sender: dict) -> bool:
    if not settings["whitelist_enabled"] or chat_id not in whitelist or not whitelist[chat_id]:
        return True

    for label, config in whitelist[chat_id].items():
        if config["type"] == "word":
            for word in config["words"]:
                if word in message_text:
                    logger.info(f"Tin nh·∫Øn kh·ªõp v·ªõi whitelist '{label}' (word: {word})")
                    return True

        elif config["type"] == "regex":
            pattern = config["pattern"]
            pattern = pattern.replace("==OR==", "|").replace("==AND==", ".*")
            try:
                if re.search(pattern, message_text):
                    logger.info(f"Tin nh·∫Øn kh·ªõp v·ªõi whitelist '{label}' (regex: {pattern})")
                    return True
            except re.error as e:
                logger.error(f"L·ªói regex trong whitelist '{label}': {e}")
                continue

        elif config["type"] == "user":
            sender_id = str(sender.get("id", ""))
            sender_username = sender.get("username", "")
            for user in config["users"]:
                if user == sender_id or (sender_username and user.lower() == sender_username.lower()):
                    logger.info(f"Tin nh·∫Øn kh·ªõp v·ªõi whitelist '{label}' (user: {user})")
                    return True

    logger.info("Tin nh·∫Øn kh√¥ng kh·ªõp v·ªõi b·∫•t k·ª≥ whitelist n√†o, b·ªè qua.")
    return False

# H√†m b·∫Øt ƒë·∫ßu chuy·ªÉn ti·∫øp v·ªõi blacklist/whitelist
def start_forwarding(chat_id, context):
    client = clients[chat_id]
    source = user_data[chat_id]["source"]
    target = user_data[chat_id]["target"]
    blacklist = user_data[chat_id].get("blacklist", {"words": [], "ids": []})
    whitelist = user_data[chat_id].get("whitelist", {"words": [], "ids": []})

    @client.on(events.NewMessage(chats=source))
    async def handler(event):
        msg_text = event.message.text or ""
        sender_id = event.message.sender_id
        sender = await event.get_sender()
        sender_info = {
            "id": sender.id if sender else None,
            "username": sender.username if sender and hasattr(sender, "username") else None
        }

        # Ki·ªÉm tra blacklist
        if any(word.lower() in msg_text.lower() for word in blacklist["words"]) or sender_id in blacklist["ids"]:
            return

        # Ki·ªÉm tra whitelist
        if (whitelist["words"] or whitelist["ids"]) and not (any(word.lower() in msg_text.lower() for word in whitelist["words"]) or sender_id in whitelist["ids"]):
            return

        # Ki·ªÉm tra whitelist n√¢ng cao
        if not check_whitelist(chat_id, msg_text, sender_info):
            return

        # √Åp d·ª•ng cleaners
        message, should_forward = apply_cleaners(chat_id, event.message)
        if not should_forward or message is None:
            return

        # X·ª≠ l√Ω tin nh·∫Øn theo forward_mode
        if settings["forward_mode"] == "forward":
            await client.forward_messages(target, message)
        else:  # copy mode
            if message.media:
                if message.photo:
                    await client.send_file(target, message.photo, caption=msg_text)
                elif message.video:
                    await client.send_file(target, message.video, caption=msg_text)
                elif message.document:
                    await client.send_file(target, message.document, caption=msg_text)
                else:
                    await client.send_message(target, msg_text)
            else:
                new_text = replace_content(chat_id, msg_text)
                await client.send_message(target, new_text)

        logging.info(f"ƒê√£ chuy·ªÉn ti·∫øp t·ª´ {source} ƒë·∫øn {target}")

        # Ghi l·∫°i v√†o statistics
        statistics["forwarded_messages"].append({
            "from_chat_id": source,
            "to_chat_id": target,
            "message_id": event.message.id,
            "timestamp": datetime.now().isoformat()
        })
        save_statistics(statistics)

# H√†m thi·∫øt l·∫≠p broadcast t·ª± ƒë·ªông
def setup_broadcast(chat_id):
    if chat_id not in clients:
        return

    client = clients[chat_id]
    source = user_data[chat_id]["source"]
    broadcast_target = user_data[chat_id].get("broadcast_target", "all")
    blacklist = user_data[chat_id].get("blacklist", {"words": [], "ids": []})
    whitelist = user_data[chat_id].get("whitelist", {"words": [], "ids": []})

    @client.on(events.NewMessage(chats=source))
    async def handler(event):
        if not user_data[chat_id].get("broadcast_enabled", False):
            return

        msg_text = event.message.text or ""
        sender_id = event.message.sender_id
        sender = await event.get_sender()
        sender_info = {
            "id": sender.id if sender else None,
            "username": sender.username if sender and hasattr(sender, "username") else None
        }

        # Ki·ªÉm tra blacklist
        if any(word.lower() in msg_text.lower() for word in blacklist["words"]) or sender_id in blacklist["ids"]:
            return

        # Ki·ªÉm tra whitelist
        if (whitelist["words"] or whitelist["ids"]) and not (any(word.lower() in msg_text.lower() for word in whitelist["words"]) or sender_id in whitelist["ids"]):
            return

        # Ki·ªÉm tra whitelist n√¢ng cao
        if not check_whitelist(chat_id, msg_text, sender_info):
            return

        # √Åp d·ª•ng cleaners
        message, should_forward = apply_cleaners(chat_id, event.message)
        if not should_forward or message is None:
            return

        # Broadcast tin nh·∫Øn
        await broadcast_message(client, message, target=broadcast_target)

        logging.info(f"ƒê√£ broadcast t·ª´ {source} ƒë·∫øn {broadcast_target}")

        # Ghi l·∫°i v√†o statistics
        statistics["forwarded_messages"].append({
            "from_chat_id": source,
            "to_chat_id": broadcast_target,
            "message_id": event.message.id,
            "timestamp": datetime.now().isoformat()
        })
        save_statistics(statistics)

# H√†m forward tin nh·∫Øn theo quy t·∫Øc forward
async def forward_message(client, from_chat_id: int, message, target_chat_ids: list):
    chat_id = list(clients.keys())[list(clients.values()).index(client)]
    message, should_forward = apply_cleaners(chat_id, message)
    if not should_forward or message is None:
        return

    for target_chat_id in target_chat_ids:
        try:
            if settings["forward_mode"] == "forward":
                await client.forward_messages(target_chat_id, message)
            else:  # copy mode
                msg_text = message.text or ""
                if message.media:
                    if message.photo:
                        await client.send_file(target_chat_id, message.photo, caption=msg_text)
                    elif message.video:
                        await client.send_file(target_chat_id, message.video, caption=msg_text)
                    elif message.document:
                        await client.send_file(target_chat_id, message.document, caption=msg_text)
                    else:
                        await client.send_message(target_chat_id, msg_text)
                else:
                    new_text = replace_content(chat_id, msg_text)
                    await client.send_message(target_chat_id, new_text)

            logger.info(f"ƒê√£ chuy·ªÉn ti·∫øp tin nh·∫Øn t·ª´ {from_chat_id} ƒë·∫øn {target_chat_id}")
            statistics["forwarded_messages"].append({
                "from_chat_id": from_chat_id,
                "to_chat_id": target_chat_id,
                "message_id": message.id,
                "timestamp": datetime.now().isoformat()
            })
            save_statistics(statistics)
        except Exception as e:
            logger.error(f"L·ªói khi chuy·ªÉn ti·∫øp tin nh·∫Øn ƒë·∫øn {target_chat_id}: {e}")

# X·ª≠ l√Ω chuy·ªÉn ti·∫øp theo quy t·∫Øc forward
def setup_forwarding(chat_id):
    if chat_id not in clients or not settings["forward_enabled"]:
        return

    client = clients[chat_id]
    if chat_id not in forward_rules or not forward_rules[chat_id]:
        return

    @client.on(events.NewMessage())
    async def handler(event):
        if not settings["forward_enabled"]:
            return

        message_text = event.message.text or ""
        sender = await event.get_sender()
        sender_info = {
            "id": sender.id if sender else None,
            "username": sender.username if sender and hasattr(sender, "username") else None
        }

        chat_id_event = event.chat_id
        target_chat_ids = []
        for label, rule in forward_rules[chat_id].items():
            if chat_id_event in rule["source_chat_ids"]:
                target_chat_ids.extend(rule["target_chat_ids"])

        if not target_chat_ids:
            return

        if check_whitelist(chat_id, message_text, sender_info):
            await forward_message(client, chat_id_event, event.message, target_chat_ids)

# ƒêƒÉng k√Ω l·ªánh v√† x·ª≠ l√Ω
application.add_handler(CommandHandler("start", start))
application.add_handler(CallbackQueryHandler(button))
application.add_handler(MessageHandler(filters.ALL & ~filters.COMMAND, handle_message))
application.add_handler(CommandHandler("forward", forward_command))
application.add_handler(CommandHandler("whitelist", whitelist_command))
application.add_handler(CommandHandler("user", user_command))
application.add_handler(CommandHandler("getchatid", getchatid))
application.add_handler(CommandHandler("getgroup", getgroup))
application.add_handler(CommandHandler("getuser", getuser))
application.add_handler(CommandHandler("filtergroups", filter_groups))
application.add_handler(CommandHandler("filterchannels", filter_channels))
application.add_handler(CommandHandler("filterusername", filter_username))
application.add_handler(CommandHandler("recentonline", recent_online))
application.add_handler(CommandHandler("statistics", statistics_command))
application.add_handler(CommandHandler("start_broadcast", start_broadcast_command))
application.add_handler(CommandHandler("stop_broadcast", stop_broadcast_command))

# Ch·∫°y bot
async def main():
    if not os.path.exists("sessions"):
        os.makedirs("sessions")
    await application.initialize()
    await application.start()
    await application.updater.start_polling()
    try:
        await asyncio.sleep(999999)
    except asyncio.CancelledError:
        await application.updater.stop()
        await application.stop()

if __name__ == "__main__":
    asyncio.run(main())
